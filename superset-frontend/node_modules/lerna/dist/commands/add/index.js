"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// libs/core/src/lib/collect-uncommitted.ts
function collectUncommitted({ cwd, log: log36 = import_npmlog.default }) {
  log36.silly("collect-uncommitted", "git status --porcelain (async)");
  return childProcess.exec("git", ["status", "--porcelain"], { cwd }).then(({ stdout }) => transformOutput(stdout));
}
var import_chalk, import_npmlog, childProcess, maybeColorize, cRed, cGreen, replaceStatus, colorizeStats, splitOnNewLine, filterEmpty, o, transformOutput;
var init_collect_uncommitted = __esm({
  "libs/core/src/lib/collect-uncommitted.ts"() {
    "use strict";
    import_chalk = __toESM(require("chalk"));
    import_npmlog = __toESM(require("npmlog"));
    childProcess = require("@lerna/child-process");
    maybeColorize = (colorize) => (s) => s !== " " ? colorize(s) : s;
    cRed = maybeColorize(import_chalk.default.red);
    cGreen = maybeColorize(import_chalk.default.green);
    replaceStatus = (_, maybeGreen, maybeRed) => `${cGreen(maybeGreen)}${cRed(maybeRed)}`;
    colorizeStats = (stats) => stats.replace(/^([^U]| )([A-Z]| )/gm, replaceStatus).replace(/^\?{2}|U{2}/gm, cRed("$&"));
    splitOnNewLine = (str) => str.split("\n");
    filterEmpty = (lines) => lines.filter((line) => line.length);
    o = (l, r) => (x) => l(r(x));
    transformOutput = o(filterEmpty, o(splitOnNewLine, colorizeStats));
  }
});

// libs/core/src/lib/describe-ref.ts
function getArgs(options, includeMergedTags = false) {
  let args = [
    "describe",
    // fallback to short sha if no tags located
    "--always",
    // always return full result, helps identify existing release
    "--long",
    // annotate if uncommitted changes present
    "--dirty",
    // prefer tags originating on upstream branch
    "--first-parent"
  ];
  if (options.match) {
    args.push("--match", options.match);
  }
  if (includeMergedTags) {
    args = args.filter((arg) => arg !== "--first-parent");
  }
  return args;
}
function describeRefSync(options = {}, includeMergedTags) {
  const stdout = childProcess2.execSync("git", getArgs(options, includeMergedTags), options);
  const result = parse(stdout, options.cwd);
  import_npmlog2.default.silly("git-describe.sync", "%j => %j", stdout, result);
  return result;
}
function parse(stdout, cwd) {
  const minimalShaRegex = /^([0-9a-f]{7,40})(-dirty)?$/;
  if (minimalShaRegex.test(stdout)) {
    const [, sha2, isDirty2] = minimalShaRegex.exec(stdout);
    const refCount2 = childProcess2.execSync("git", ["rev-list", "--count", sha2], { cwd });
    return { refCount: refCount2, sha: sha2, isDirty: Boolean(isDirty2) };
  }
  const [, lastTagName, lastVersion, refCount, sha, isDirty] = /^((?:.*@)?(.*))-(\d+)-g([0-9a-f]+)(-dirty)?$/.exec(stdout) || [];
  return { lastTagName, lastVersion, refCount, sha, isDirty: Boolean(isDirty) };
}
var import_npmlog2, childProcess2;
var init_describe_ref = __esm({
  "libs/core/src/lib/describe-ref.ts"() {
    "use strict";
    import_npmlog2 = __toESM(require("npmlog"));
    childProcess2 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/validation-error.ts
var import_npmlog3, ValidationError;
var init_validation_error = __esm({
  "libs/core/src/lib/validation-error.ts"() {
    "use strict";
    import_npmlog3 = __toESM(require("npmlog"));
    ValidationError = class extends Error {
      prefix;
      constructor(prefix, message, ...rest) {
        super(message);
        this.name = "ValidationError";
        this.prefix = prefix;
        import_npmlog3.default.resume();
        import_npmlog3.default.error(prefix, message, ...rest);
      }
    };
  }
});

// libs/core/src/lib/check-working-tree.ts
function mkThrowIfUncommitted(options = {}) {
  return function throwIfUncommitted2({ isDirty }) {
    if (isDirty) {
      return collectUncommitted(options).then((uncommitted) => {
        throw new ValidationError("EUNCOMMIT", `${EUNCOMMIT_MSG}${uncommitted.join("\n")}`);
      });
    }
  };
}
var EUNCOMMIT_MSG, throwIfUncommitted;
var init_check_working_tree = __esm({
  "libs/core/src/lib/check-working-tree.ts"() {
    "use strict";
    init_collect_uncommitted();
    init_describe_ref();
    init_validation_error();
    EUNCOMMIT_MSG = "Working tree has uncommitted changes, please commit or remove the following changes before continuing:\n";
    throwIfUncommitted = mkThrowIfUncommitted();
  }
});

// libs/core/src/lib/cli.ts
var import_dedent, import_npmlog4, import_yargs;
var init_cli = __esm({
  "libs/core/src/lib/cli.ts"() {
    "use strict";
    import_dedent = __toESM(require("dedent"));
    import_npmlog4 = __toESM(require("npmlog"));
    import_yargs = __toESM(require("yargs/yargs"));
  }
});

// libs/core/src/lib/collect-updates/collect-dependents.ts
function collectDependents(nodes) {
  const collected = /* @__PURE__ */ new Set();
  nodes.forEach((currentNode) => {
    if (currentNode.localDependents.size === 0) {
      return;
    }
    const queue2 = [currentNode];
    const seen = /* @__PURE__ */ new Set();
    const visit = (dependentNode, dependentName, siblingDependents) => {
      if (seen.has(dependentNode)) {
        return;
      }
      seen.add(dependentNode);
      if (dependentNode === currentNode || siblingDependents.has(currentNode.name)) {
        return;
      }
      collected.add(dependentNode);
      queue2.push(dependentNode);
    };
    while (queue2.length) {
      const node = queue2.shift();
      node.localDependents.forEach(visit);
    }
  });
  return collected;
}
var init_collect_dependents = __esm({
  "libs/core/src/lib/collect-updates/collect-dependents.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/collect-updates/collect-packages.ts
function collectPackages(packages, { isCandidate = () => true, onInclude, excludeDependents } = {}) {
  const candidates = /* @__PURE__ */ new Set();
  packages.forEach((node, name) => {
    if (isCandidate(node, name)) {
      candidates.add(node);
    }
  });
  if (!excludeDependents) {
    collectDependents(candidates).forEach((node) => candidates.add(node));
  }
  const updates = [];
  packages.forEach((node, name) => {
    if (candidates.has(node)) {
      if (onInclude) {
        onInclude(name);
      }
      updates.push(node);
    }
  });
  return updates;
}
var init_collect_packages = __esm({
  "libs/core/src/lib/collect-updates/collect-packages.ts"() {
    "use strict";
    init_collect_dependents();
  }
});

// libs/core/src/lib/collect-updates/get-packages-for-option.ts
function getPackagesForOption(option) {
  let inputs = null;
  if (option === true) {
    inputs = ["*"];
  } else if (typeof option === "string") {
    inputs = option.split(",");
  } else if (Array.isArray(option)) {
    inputs = [...option];
  }
  return new Set(inputs);
}
var init_get_packages_for_option = __esm({
  "libs/core/src/lib/collect-updates/get-packages-for-option.ts"() {
    "use strict";
  }
});

// libs/core/src/lib/collect-updates/has-tags.ts
function hasTags(opts) {
  import_npmlog5.default.silly("hasTags");
  let result = false;
  try {
    result = !!childProcess3.execSync("git", ["tag"], opts);
  } catch (err) {
    import_npmlog5.default.warn("ENOTAGS", "No git tags were reachable from this branch!");
    import_npmlog5.default.verbose("hasTags error", err);
  }
  import_npmlog5.default.verbose("hasTags", result);
  return result;
}
var import_npmlog5, childProcess3;
var init_has_tags = __esm({
  "libs/core/src/lib/collect-updates/has-tags.ts"() {
    "use strict";
    import_npmlog5 = __toESM(require("npmlog"));
    childProcess3 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/make-diff-predicate.ts
function makeDiffPredicate(committish, execOpts, ignorePatterns = []) {
  const ignoreFilters = new Set(
    ignorePatterns.map(
      (p) => import_minimatch.default.filter(`!${p}`, {
        matchBase: true,
        // dotfiles inside ignored directories should also match
        dot: true
      })
    )
  );
  if (ignoreFilters.size) {
    import_npmlog6.default.info("ignoring diff in paths matching", ignorePatterns);
  }
  return function hasDiffSinceThatIsntIgnored(node) {
    const diff = diffSinceIn(committish, node.location, execOpts);
    if (diff === "") {
      import_npmlog6.default.silly("", "no diff found in %s", node.name);
      return false;
    }
    import_npmlog6.default.silly("found diff in", diff);
    let changedFiles = diff.split("\n");
    if (ignoreFilters.size) {
      for (const ignored of ignoreFilters) {
        changedFiles = changedFiles.filter(ignored);
      }
    }
    if (changedFiles.length) {
      import_npmlog6.default.verbose("filtered diff", changedFiles);
    } else {
      import_npmlog6.default.verbose("", "no diff found in %s (after filtering)", node.name);
    }
    return changedFiles.length > 0;
  };
}
function diffSinceIn(committish, location, opts) {
  const args = ["diff", "--name-only", committish];
  const formattedLocation = (0, import_slash.default)(import_path.default.relative(opts.cwd, location));
  if (formattedLocation) {
    args.push("--", formattedLocation);
  }
  import_npmlog6.default.silly("checking diff", formattedLocation);
  return childProcess4.execSync("git", args, opts);
}
var import_npmlog6, import_minimatch, import_path, import_slash, childProcess4;
var init_make_diff_predicate = __esm({
  "libs/core/src/lib/collect-updates/make-diff-predicate.ts"() {
    "use strict";
    import_npmlog6 = __toESM(require("npmlog"));
    import_minimatch = __toESM(require("minimatch"));
    import_path = __toESM(require("path"));
    import_slash = __toESM(require("slash"));
    childProcess4 = require("@lerna/child-process");
  }
});

// libs/core/src/lib/collect-updates/index.ts
function collectUpdates(filteredPackages, packageGraph, execOpts, commandOptions) {
  const { forcePublish, conventionalCommits, conventionalGraduate, excludeDependents } = commandOptions;
  const useConventionalGraduate = conventionalCommits && conventionalGraduate;
  const forced = getPackagesForOption(useConventionalGraduate ? conventionalGraduate : forcePublish);
  const packages = filteredPackages.length === packageGraph.size ? packageGraph : new Map(filteredPackages.map(({ name }) => [name, packageGraph.get(name)]));
  let committish = commandOptions.since;
  if (hasTags(execOpts)) {
    const { sha, refCount, lastTagName } = describeRefSync(execOpts, commandOptions.includeMergedTags);
    if (refCount === "0" && forced.size === 0 && !committish) {
      import_npmlog7.default.notice("", "Current HEAD is already released, skipping change detection.");
      return [];
    }
    if (commandOptions.canary) {
      committish = `${sha}^..${sha}`;
    } else if (!committish) {
      committish = lastTagName;
    }
  }
  if (forced.size) {
    import_npmlog7.default.warn(
      useConventionalGraduate ? "conventional-graduate" : "force-publish",
      forced.has("*") ? "all packages" : Array.from(forced.values()).join("\n")
    );
  }
  if (useConventionalGraduate) {
    if (forced.has("*")) {
      import_npmlog7.default.info("", "Graduating all prereleased packages");
    } else {
      import_npmlog7.default.info("", "Graduating prereleased packages");
    }
  } else if (!committish || forced.has("*")) {
    import_npmlog7.default.info("", "Assuming all packages changed");
    return collectPackages(packages, {
      onInclude: (name) => import_npmlog7.default.verbose("updated", name),
      excludeDependents
    });
  }
  import_npmlog7.default.info("", `Looking for changed packages since ${committish}`);
  const hasDiff = makeDiffPredicate(committish, execOpts, commandOptions.ignoreChanges);
  const needsBump = !commandOptions.bump || commandOptions.bump.startsWith("pre") ? () => false : (
    /* skip packages that have not been previously prereleased */
    // TODO: refactor to address type issues
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    (node) => node.prereleaseId
  );
  const isForced = (node, name) => (forced.has("*") || forced.has(name)) && (useConventionalGraduate ? node.prereleaseId : true);
  return collectPackages(packages, {
    // TODO: refactor to address type issues
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    isCandidate: (node, name) => isForced(node, name) || needsBump(node) || hasDiff(node),
    onInclude: (name) => import_npmlog7.default.verbose("updated", name),
    excludeDependents
  });
}
var import_npmlog7;
var init_collect_updates = __esm({
  "libs/core/src/lib/collect-updates/index.ts"() {
    "use strict";
    import_npmlog7 = __toESM(require("npmlog"));
    init_describe_ref();
    init_collect_packages();
    init_get_packages_for_option();
    init_has_tags();
    init_make_diff_predicate();
  }
});

// libs/core/src/lib/package-graph/cyclic-package-graph-node.ts
var lastCollapsedNodeId, CyclicPackageGraphNode;
var init_cyclic_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/cyclic-package-graph-node.ts"() {
    "use strict";
    lastCollapsedNodeId = 0;
    CyclicPackageGraphNode = class extends Map {
      name;
      localDependencies;
      localDependents;
      constructor() {
        super();
        this.name = `(cycle) ${lastCollapsedNodeId += 1}`;
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      // eslint-disable-next-line class-methods-use-this
      get isCycle() {
        return true;
      }
      /**
       * @returns A representation of a cycle, like like `A -> B -> C -> A`.
       */
      toString() {
        const parts = Array.from(
          this,
          ([key, node]) => (
            // TODO: refactor to address type issues
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            node.isCycle ? `(nested cycle: ${node.toString()})` : key
          )
        );
        parts.push(parts[0]);
        return parts.reverse().join(" -> ");
      }
      /**
       * Flattens a CyclicPackageGraphNode (which can have multiple level of cycles).
       */
      flatten() {
        const result = [];
        for (const node of this.values()) {
          if (node.isCycle) {
            result.push(...node.flatten());
          } else {
            result.push(node);
          }
        }
        return result;
      }
      /**
       * Checks if a given node is contained in this cycle (or in a nested one)
       *
       * @param name The name of the package to search in this cycle
       */
      contains(name) {
        for (const [currentName, currentNode] of this) {
          if (currentNode.isCycle) {
            if (currentNode.contains(name)) {
              return true;
            }
          } else if (currentName === name) {
            return true;
          }
        }
        return false;
      }
      /**
       * Adds a graph node, or a nested cycle, to this group.
       */
      insert(node) {
        this.set(node.name, node);
        this.unlink(node);
        for (const [dependencyName, dependencyNode] of node.localDependencies) {
          if (!this.contains(dependencyName)) {
            this.localDependencies.set(dependencyName, dependencyNode);
          }
        }
        for (const [dependentName, dependentNode] of node.localDependents) {
          if (!this.contains(dependentName)) {
            this.localDependents.set(dependentName, dependentNode);
          }
        }
      }
      /**
       * Remove pointers to candidate node from internal collections.
       * @param candidateNode instance to unlink
       */
      unlink(candidateNode) {
        this.localDependencies.delete(candidateNode.name);
        this.localDependents.delete(candidateNode.name);
      }
    };
  }
});

// libs/core/src/lib/prerelease-id-from-version.ts
function prereleaseIdFromVersion(version) {
  return (import_semver.default.prerelease(version) || []).shift();
}
var import_semver;
var init_prerelease_id_from_version = __esm({
  "libs/core/src/lib/prerelease-id-from-version.ts"() {
    "use strict";
    import_semver = __toESM(require("semver"));
  }
});

// libs/core/src/lib/package-graph/package-graph-node.ts
var import_semver2, PKG, PackageGraphNode;
var init_package_graph_node = __esm({
  "libs/core/src/lib/package-graph/package-graph-node.ts"() {
    "use strict";
    import_semver2 = __toESM(require("semver"));
    init_prerelease_id_from_version();
    PKG = Symbol("pkg");
    PackageGraphNode = class {
      name;
      externalDependencies;
      localDependencies;
      localDependents;
      [PKG];
      constructor(pkg) {
        this.name = pkg.name;
        this[PKG] = pkg;
        Object.defineProperty(this, PKG, { enumerable: false });
        this.externalDependencies = /* @__PURE__ */ new Map();
        this.localDependencies = /* @__PURE__ */ new Map();
        this.localDependents = /* @__PURE__ */ new Map();
      }
      get location() {
        return this[PKG].location;
      }
      get pkg() {
        return this[PKG];
      }
      get prereleaseId() {
        return prereleaseIdFromVersion(this.version);
      }
      get version() {
        return this[PKG].version;
      }
      /**
       * Determine if the Node satisfies a resolved semver range.
       * @see https://github.com/npm/npm-package-arg#result-object
       *
       * @param {!Result} resolved npm-package-arg Result object
       */
      satisfies({ gitCommittish, gitRange, fetchSpec }) {
        return import_semver2.default.satisfies(this.version, gitCommittish || gitRange || fetchSpec);
      }
      /**
       * Returns a string representation of this node (its name)
       *
       * @returns {String}
       */
      to